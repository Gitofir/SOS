@model WebApp.Models.User
@{

    ViewData["Title"] = "Statistics";
    var ownedStocks = Model.OwnedStocks;
    bool hasStocks = false; //change to false after db will work


    Dictionary<string, int> AmountFromCategory = new Dictionary<string, int>(); //all users have null in owned stocks
    if (Model.OwnedStocks != null)
    {
        hasStocks = true;
        foreach (Stock stock in Model.OwnedStocks)
        {
            if (!AmountFromCategory.TryAdd(stock.Category, 1))
                AmountFromCategory[stock.Category]++;
        }
    }
    else
    {

        //AmountFromCategory.Add("No stocks", 1); 
        AmountFromCategory.Add("finance", 2); //just to continue with list WILL BE DELETED
        AmountFromCategory["finance"]++;
        AmountFromCategory.Add("cars", 1);
        AmountFromCategory.Add("tech", 3);
        AmountFromCategory["finance"]++;

    }
}

<script src="~/lib/d3/d3.min.js"></script>
<h1>Statistics</h1> <hr />

<body>
    <div>
        @if (hasStocks)
        {
            <section class="row py-sm-4">
                <section class="col-3">
                    @foreach (var pair in AmountFromCategory) //display the temporry list - after that ill change it to mikra
                    {
                        <dt class="col-sm-2">
                            @pair.Key
                        </dt>
                        <dd class="col-sm-10">
                            @pair.Value
                        </dd>
                    }
                </section>

                <section class="col-3 " id="stocksbycategory">
                </section>


            </section>

            <section class="row py-sm-4">
                <section class="col-3 ">
                    @foreach (var pair in AmountFromCategory) //display the temporry list - after that ill change it to mikra
                    {
                        <dt class="col-sm-2">
                            @pair.Key
                        </dt>
                        <dd class="col-sm-10">
                            @pair.Value
                        </dd>
                    }
                </section>

                <section class="col-3" id="stocksbyindex">
                </section>
                <lable class="alert-dark" itemid="nostocks"></lable>

            </section>
        }
        else
        {
            <h2 class="text-center">You dont own any stocks yet</h2> //add here link to buy and sell page
        }
    </div>
</body>

<script>
    // set the dimensions and margins of the graph
    const width = 250,
        height = 250,
        margin = 8;

    // The radius of the pieplot is half the width or half the height (smallest one). I subtract a bit of margin.
    const radius = Math.min(width, height) / 2 - margin;


    //Owned Stocks By Category
    //---------------------------------------------------------------------------------------


    // append the svg object to the div
    const svgcat = d3.select("#stocksbycategory")
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        .append("g")
        .attr("transform", `translate(${width / 2}, ${height / 2})`);

    // Create dummy data
    //const datacat = { a: 9, b: 20, c: 30, d: 8, e: 12 }

    const datacat = { finance: @AmountFromCategory["finance"], cars: @AmountFromCategory["cars"], tech: @AmountFromCategory["tech"]}


    // set the color scale
    const colorcat = d3.scaleOrdinal()
        .range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56"])

    // Compute the position of each group on the pie:
    const piecat = d3.pie()
        .value(function (d) { return d[1] })
    /**/
    //const data_readycat = piecat(Object.entries(datacat))
    const data_readycat = piecat(Object.entries(datacat))

    /**/

    // Build the pie chart: Basically, each part of the pie is a path that we build using the arc function.
    svgcat
        .selectAll('whatever')
        .data(data_readycat)
        .join('path')
        .attr('d', d3.arc()
            .innerRadius(0)
            .outerRadius(radius)
        )
        .attr('fill', function (d) { return (colorcat(d.data[1])) })
        .attr("stroke", "black")
        .style("stroke-width", "1px")
        .style("opacity", 0.7)


    //Owned Stocks By index
    //---------------------------------------------------------------------------------------


    // append the svg object to the div
    const svgindex = d3.select("#stocksbyindex")
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        .append("g")
        .attr("transform", `translate(${width / 2}, ${height / 2})`);

    // Create dummy data
    const dataindex = { a: 0, b: 1, c: 0 }

    // set the color scale
    const colorindex = d3.scaleOrdinal()
        .range(["#05f6f5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56"])

    // Compute the position of each group on the pie:
    const pieindex = d3.pie()
        .value(function (d) { return d[1] })
    const data_readyindex = pieindex(Object.entries(dataindex))

    // Build the pie chart: Basically, each part of the pie is a path that we build using the arc function.
    svgindex
        .selectAll('whatever')
        .data(data_readyindex)
        .join('path')
        .attr('d', d3.arc()
            .innerRadius(0)
            .outerRadius(radius)
        )
        .attr('fill', function (d) { return (colorindex(d.data[1])) })
        .attr("stroke", "black")
        .style("stroke-width", "2px")
        .style("opacity", 0.7)

   //----------------------------------------------------------//
   //----------------------------------------------------------//
                        //NEW GRAPH
   //----------------------------------------------------------//
   //----------------------------------------------------------//
    @*var data=@AmountFromCategory.ToArray();
    function PieChart(data, {
        name = ([x]) => x,  // given d in data, returns the (ordinal) label
        value = ([, y]) => y, // given d in data, returns the (quantitative) value
        title, // given d in data, returns the title text
        width = 640, // outer width, in pixels
        height = 400, // outer height, in pixels
        innerRadius = 0, // inner radius of pie, in pixels (non-zero for donut)
        outerRadius = Math.min(width, height) / 2, // outer radius of pie, in pixels
        labelRadius = (innerRadius * 0.2 + outerRadius * 0.8), // center radius of labels
        format = ",", // a format specifier for values (in the label)
        names, // array of names (the domain of the color scale)
        colors, // array of colors for names
        stroke = innerRadius > 0 ? "none" : "white", // stroke separating widths
        strokeWidth = 1, // width of stroke separating wedges
        strokeLinejoin = "round", // line join of stroke separating wedges
        padAngle = stroke === "none" ? 1 / outerRadius : 0, // angular separation between wedges
    } = {}) {
        // Compute values.
        const N = d3.map(data, name);
        const V = d3.map(data, value);
        const I = d3.range(N.length).filter(i => !isNaN(V[i]));

        // Unique the names.
        if (names === undefined) names = N;
        names = new d3.InternSet(names);

        // Chose a default color scheme based on cardinality.
        if (colors === undefined) colors = d3.schemeSpectral[names.size];
        if (colors === undefined) colors = d3.quantize(t => d3.interpolateSpectral(t * 0.8 + 0.1), names.size);

        // Construct scales.
        const color = d3.scaleOrdinal(names, colors);

        // Compute titles.
        if (title === undefined) {
            const formatValue = d3.format(format);
            title = i => `${N[i]}\n${formatValue(V[i])}`;
        } else {
            const O = d3.map(data, d => d);
            const T = title;
            title = i => T(O[i], i, data);
        }

        // Construct arcs.
        const arcs = d3.pie().padAngle(padAngle).sort(null).value(i => V[i])(I);
        const arc = d3.arc().innerRadius(innerRadius).outerRadius(outerRadius);
        const arcLabel = d3.arc().innerRadius(labelRadius).outerRadius(labelRadius);

        const svg = d3.create("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [-width / 2, -height / 2, width, height])
            .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

        svg.append("g")
            .attr("stroke", stroke)
            .attr("stroke-width", strokeWidth)
            .attr("stroke-linejoin", strokeLinejoin)
            .selectAll("path")
            .data(arcs)
            .join("path")
            .attr("fill", d => color(N[d.data]))
            .attr("d", arc)
            .append("title")
            .text(d => title(d.data));

        svg.append("g")
            .attr("font-family", "sans-serif")
            .attr("font-size", 10)
            .attr("text-anchor", "middle")
            .selectAll("text")
            .data(arcs)
            .join("text")
            .attr("transform", d => `translate(${arcLabel.centroid(d)})`)
            .selectAll("tspan")
            .data(d => {
                const lines = `${title(d.data)}`.split(/\n/);
                return (d.endAngle - d.startAngle) > 0.25 ? lines : lines.slice(0, 1);
            })
            .join("tspan")
            .attr("x", 0)
            .attr("y", (_, i) => `${i * 1.1}em`)
            .attr("font-weight", (_, i) => i ? null : "bold")
            .text(d => d);

        return Object.assign(svg.node(), { scales: { color } });
    }*@

</script>


